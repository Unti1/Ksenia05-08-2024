'''Конечно! Давай придумаем еще одну задачу, в которой можно применить многозадачность, очереди, локи и демонские потоки.
 Пусть это будет задача для обработки данных, которые поступают в систему в виде пакетов.

Задача: Обработка пакетов данных с использованием многозадачности
Представь, что у нас есть система, которая получает пакеты данных от различных источников (например, с датчиков).
 Эти пакеты нужно обрабатывать в несколько этапов:

Принятие данных (вставить пакет в очередь).
Обработка данных (например, фильтрация и анализ).
Запись результатов (сохранение результата обработки в файл).
Чтобы ускорить обработку, мы будем использовать многозадачность, где несколько потоков будут параллельно обрабатывать 
эти пакеты. Также будет использоваться очередь для упорядочивания пакетов и блокировки для синхронизации доступа к общим данным.

Условия задачи:
Мы создаем очередь для пакетов данных.
Используем 3 потока:
Один поток будет принимать пакеты и вставлять их в очередь.
Два других потока будут обрабатывать пакеты из очереди, выполняя фильтрацию и анализ.
После обработки пакеты записываются в файл.
Потоки должны быть демонскими, чтобы программа завершалась, как только все задачи будут обработаны.
'''

from queue import Queue
import time
import threading
import random

a=Queue()
lock=threading.Lock()

all=[]

def v(paket):
    a.put(paket)
    print(f'{paket} vstavlen')
def obr(paket):
    time.sleep(random.uniform(1,3))
    with lock:
        return f'{paket} obrabotan'
def zap(paket):
    time.sleep(random.uniform(1,3))
    with lock:
        return f'{paket} zapisan'
def result():
    while not a.empty():
        paket = a.get()  # Извлекаем пакет из очереди
        with lock:
            print(f'Obrabotka start {paket}')
        
        obr_result = obr(paket)  # Обрабатываем пакет
        zap_result = zap(obr_result)  # Записываем результат
        
        with lock:
            all.append(zap_result)  # Сохраняем результат в список
            print(f'end obrabotka {paket}')  # Сообщаем об окончании обработки
        
        a.task_done()  # Уведомляем очередь, что работа с элементом завершена
        print(zap_result)  # Печатаем результат     
if __name__=="__main__":
    x=[f'paken#{r}'for r in range(5)]  
    tht=[]  
    for xx in x:
        t=threading.Thread(target=v,args=(xx,),daemon=True)  
        tht.append(t)
        t.start() 
    for t in tht:
        t.join()   
    t1=threading.Thread(target=result,daemon=True)
    
    t1.start()
   
    t1.join()
    











        

